---
title: "Week 2 Exercises: Ownership and structs"
tags: [Stanford,CS110L,Rust,System Programming]
toc_max_heading_level: 5
--- 
 
### Part 1: Ownership short-answer exercises

#### Example 1:

```rust
fn main() {
    let mut s = String::from("hello");
    let ref1 = &s;
    let ref2 = &ref1;
    let ref3 = &ref2;
    s = String::from("goodbye");
    println!("{}", ref3.to_uppercase());
}
```
From [Rust documentation](https://doc.rust-lang.org/error-index.html), this is a compile error of An attempt was made to assign to a borrowed value. The ownership rule of rust declare that if a variable's reference have been hold by another reference, the variable itself cannot be assign a new value.
```rust
error[E0506]: cannot assign to `s` because it is borrowed
 --> src/main.rs:6:5
  |
3 |     let ref1 = &s;
  |                -- borrow of `s` occurs here
...
6 |     s = String::from("goodbye");
  |     ^ assignment to borrowed `s` occurs here
7 |     println!("{}", ref3.to_uppercase());
  |                    ------------------- borrow later used here
```

##### Amendment

Remove all reference, use call by value instead.
```rust
fn main() {
    let mut s = String::from("hello");
    let ref1 =  s;
    let ref2 =  ref1;
    let ref3 =  ref2;
    s = String::from("goodbye");
    println!("{}", ref3.to_uppercase());
}
```


#### Example 2:
Main function missing 
If this is a function by itself, then the return value should not be a borrowing value. (E0106)
```rust
fn drip_drop() -> &String {
    let s = String::from("hello world!");
    return &s;
}
```
Amendment
```rust
fn drip_drop() -> String {
    let s = String::from("hello world!");
    return s;
}
```
#### Example 3:
```rust
fn main() {
    let s1 = String::from("hello");
    let mut v = Vec::new();
    v.push(s1);
    let s2: String = v[0];
    println!("{}", s2);
}
```

##### Amendment
```rust
fn main() {
    let s1 = String::from("hello");
    let mut v = Vec::new();
    v.push(s1);
    let ref s2: String = v[0];
    println!("{}", s2);
}
```
### Part 2: rdiff

#### Milestone 1: Reading the two files into vectors of lines

`fn read_file_lines(filename: &String) -> Result<Vec<String>, io::Error>` will take in a filename and return a result data type which includes a vec of string if no error, or an error if error existed

```rust
fn read_file_lines(filename: &String) -> Result<Vec<String>, io::Error> { 
    let file = File::open(filename)?;  
    let mut v = Vec::new();
       for line in io::BufReader::new(file).lines() {
        let line_str = line?;
        v.push(line_str); 
    } 
    Ok(v) 
}
```

#### Milestone 2: Implementing the Grid interface

Unlike C++ there is no such thing as nullptr which can point to non-valid location, 'Option<T>' need to be use when we want a `null`.
This is also an example of how to use `Err()` and `Ok()` for `Result<T, E>`
```rust
pub fn get(&self, row: usize, col: usize) -> Option<usize> {
    if row >= self.num_rows || col >= self.num_cols {
        None 
    } else {
        Some(self.elems[row*self.num_cols + col]) 
    } 
}

pub fn set(&mut self, row: usize, col: usize, val: usize) -> Result<(), &'static str> { 
    if row >= self.num_rows || col >= self.num_cols { 
        Err("out of bound")
    } else {
        self.elems[row*self.num_cols + col ] = val;
        Ok(()) 
    }   
}
```

#### Milestone 3: Implementing Longest Common Subsequence
Here is just a direct convert of the psedo code to rust code, nth relly special.
```rust
fn lcs(seq1: &Vec<String>, seq2: &Vec<String>) -> Grid { 
    let m = seq1.len();
    let n = seq2.len();
    let mut c = grid::Grid::new (m+1,n+1); 
    for i in 0..m+1 {
        c.set(i,0,0).unwrap();
    }
    for i in 0..n+1 {
        c.set(0,i,0).unwrap();
    }
    for i in 0..m {
        for j in 0..n {
            if seq1[i]==seq2[j]{
                let val = c.get(i,j).unwrap() + 1;
                 c.set(i+1,j+1,val).unwrap();
            } else {
                let val1 = c.get(i+1,j).unwrap() ;
                let val2 = c.get(i,j+1).unwrap() ;
                c.set(i+1,j+1,max(val1,val2)).unwrap();
            }
        }
    }
    return c; 
}
```

#### Milestone 4: Using LCS to construct the full diff
Here is just a direct convert of the psedo code to rust code, nth relly special.
```rust
fn print_diff(lcs_table: &Grid, lines1: &Vec<String>, lines2: &Vec<String>, i: usize, j: usize) {
    if i > 0 && j > 0 && lines1[i-1] == lines2[j-1] {
        print_diff(lcs_table,lines1,lines2,i-1,j-1);
        println!("  {}",lines1[i-1]);
    } else if j > 0 && (i==0 || lcs_table.get(i,j-1).unwrap() >= lcs_table.get(i-1,j).unwrap()) {
        print_diff(lcs_table,lines1,lines2,i ,j-1);
        println!("> {}",lines2[j-1]);
    } else if i > 0 && (j==0 || lcs_table.get(i,j-1).unwrap() <lcs_table.get(i-1,j).unwrap()) {
        print_diff(lcs_table,lines1,lines2,i-1,j );
        println!("< {}",lines1[i-1]);
    } else {
        print!("");
    } 
}

 
fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 3 {
        println!("Too few arguments.");
        process::exit(1);
    }
    let filename1 = &args[1];
    let filename2 = &args[2];

    let line1 = read_file_lines(filename1).unwrap();
    let line2 = read_file_lines(filename2).unwrap();

    let lcs  = lcs(&line1,&line2);
    print_diff(&lcs ,&line1 ,&line2 ,line1.len(),line2.len());
}
```
### Optional: rwc

### Optional challenge: Conwayâ€™s Game of Life
 
### Course Material:
[Course Website](https://reberhardt.com/cs110l/spring-2020/)  
[Hangout](https://reberhardt.com/cs110l/spring-2020/assignments/week-2-exercises/)