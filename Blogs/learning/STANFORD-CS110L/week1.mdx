---
title: "Week 1 Exercises: Hello world"
tags: [Stanford,CS110L,Rust,System Programming]
--- 

### Part 1: Hello world

There are 3 command introduced in this section

 1. `cargo build` to compile the code  
 2. `cargo run` to compile and run the code 
 3. `cargo test` to run the tests

### Part 2: warmup

#### Variables
Unlike most of the other languages, variable are default to be constant, which is not mutable, to declare a mutable variable,
```rust 
 let mut retv: Vec<i32> = Vec::new();
 let mut elements = HashSet::new();
 let mut n: i32 = 1; 
```

There is a pretty cute feature in rust, which is called "type interface", which the compiler could figure out the type that the data should be.

```rust 
 let mut n = 1; 
```

We need to implement 3 function in this section, 
 - Implement `add_n`, which takes a vector of numbers and some number n. The function should return a new vector whose elements are the numbers in the original vector v with n added to each number.
 - Implement `add_n_inplace`, which does the same thing as add_n, but modifies v directly (in place) and does not return anything.
 - Implement `dedup` that removes duplicate elements from a vector in-place (i.e. modifies v directly). If an element is repeated anywhere in the vector, you should keep the element that appears first. You may want to use a HashSet for this.

#### add_n
The parameter `v: Vec<i32>` is a constant, so there is not any way to implement this function in place, but require declaring a new vector.

```rust
fn add_n(v: Vec<i32>, n: i32) -> Vec<i32> {
    let mut retv: Vec<i32> = Vec::new();
    for i in v.iter()  { 
        retv.push(i + n);
    }
    return retv;
}
```
#### add_n_inplace
The parameter `v: &mut Vec<i32>` is a mutable vector, so we could make changes to vector directly.

```rust
fn add_n_inplace(v: &mut Vec<i32>, n: i32) {
    for i in 0..v.len() {
        v[i] = v[i] + n;
    }
}
```

#### dedup

Declare a hashset `elements` to keep track every unique element in the `v: &mut Vec<i32>`

```rust
fn dedup(v: &mut Vec<i32>) {
    let mut elements = HashSet::new();
    let mut newv : Vec<i32> = Vec::new();
    for i in 0..v.len() {
        if elements.contains(&v[i]){
            continue;
        } else {
            newv.push(v[i]);
            elements.insert(v[i]);
        } 
    }
    v.clear();
    for i in 0..newv.len() { 
        v.push(newv[i]);
    }
}
```

### Part 3: Hangman 
I write a separate [blog](../../projects/rust-hangman) for this mini-project.

### Course Material:
[Course Website](https://reberhardt.com/cs110l/spring-2020/)  
[Hangout](https://reberhardt.com/cs110l/spring-2020/assignments/week-1-exercises/)

